
import { existsSync, writeFileSync } from "fs";
import { readFile, writeFile, rename, appendFile, unlink } from "fs/promises";
import { Mutex } from "./utils.js";
import { match } from "./query.js";
import {
  SencilloDBError,
  CollectionNotFoundError,
  IndexNotFoundError,
  DocumentNotFoundError,
  ValidationError,
  DatabaseNotLoadedError,
} from "./errors.js";

export interface SencilloConfig {
  file?: string;
  loadHook?: () => Promise<string>;
  saveHook?: (json: string) => Promise<void>;
  aof?: boolean;
}

export interface Populate {
  field: string;
  collection: string;
  targetField?: string;
}

export interface Instructions {
  collection?: string;
  index?: string | ((data: any) => string) | { current: string; new: string | ((data: any) => string) };
  data?: any;
  _id?: number;
  callback?: (item: any) => boolean;
  filter?: any;
  sort?: (a: any, b: any) => number;
  populate?: Populate[];
}

export interface Transaction {
  create: (instructions: Instructions) => any;
  update: (instructions: Instructions) => any;
  destroy: (instructions: Instructions) => any;
  find: (instructions: Instructions) => any;
  findMany: (instructions: Instructions) => any[];
  createMany: (instructions: Instructions) => any[];
  dropCollection: (instructions: Instructions) => void;
  dropIndex: (instructions: Instructions) => void;
  rewriteCollection: (instructions: Instructions) => void;
  ensureIndex: (instructions: { collection: string; field: string }) => void;
}

export interface CollectionStats {
  inserted: number;
  total: number;
}

export interface Collection {
  [index: string]: any[] | CollectionStats | { [field: string]: { [value: string]: number[] } } | { [id: number]: string } | undefined;
  __stats: CollectionStats;
  __secondary_indexes?: { [field: string]: { [value: string]: number[] } };
  __id_map?: { [id: number]: string };
}

interface Database {
  [key: string]: Collection;
}

export class SencilloDB {
  #file: string;
  #aofFile: string;
  #db: Database | undefined;
  #loadHook: (() => Promise<string>) | undefined;
  #saveHook: ((json: string) => Promise<void>) | undefined;
  #mutex = new Mutex();
  #aof: boolean;
  #pendingOperations: { op: string; instructions: any }[] = [];

  constructor(config: SencilloConfig = { file: "./sencillo.json" }) {
    if (!config.file && !config.loadHook && !config.saveHook) {
      // Allow if hooks are provided, otherwise file is required (default provided in arg)
      // But logic below checks config.file
    }
    
    // If no file provided and no hooks, default is used.
    // If file provided, check existence.
    const filePath = config.file || "./sencillo.json";

    if (!config.loadHook && !existsSync(filePath)) {
      writeFileSync(filePath, "{}");
    }

    this.#file = filePath;
    this.#aofFile = `${filePath}.aof`;
    this.#loadHook = config.loadHook;
    this.#saveHook = config.saveHook;
    this.#aof = config.aof || false;
  }

  async #loadDB() {
    const jsonString = this.#loadHook
      ? await this.#loadHook()
      : await readFile(this.#file, "utf-8");

    try {
      this.#db = JSON.parse(jsonString);
      
      // Replay AOF if enabled and exists
      if (this.#aof && existsSync(this.#aofFile)) {
          const aofContent = await readFile(this.#aofFile, "utf-8");
          const lines = aofContent.split("\n").filter(line => line.trim() !== "");
          for (const line of lines) {
              try {
                  const { op, instructions } = JSON.parse(line);
                  // We need to execute the operation without triggering new AOF writes or saves
                  // But our methods push to pendingOperations.
                  // We can temporarily disable AOF tracking or just clear pendingOperations after replay.
                  // Since we are inside #loadDB which is called before any transaction, 
                  // we can just call the methods and then clear pendingOperations.
                  // Also, we need to make sure we don't double-apply if the snapshot already includes it.
                  // AOF is usually used *instead* of frequent snapshots.
                  // If we have a snapshot + AOF, we assume AOF contains operations *after* the snapshot.
                  
                  // @ts-ignore
                  this[op](instructions);
              } catch (e) {
                  console.error("Failed to replay AOF line:", line, e);
              }
          }
          this.#pendingOperations = []; // Clear operations generated by replay
      }
    } catch (error) {
      throw "****file exists and doesn't contain valid json, fix the json or delete the file to create a new one****";
    }
  }

  async #saveDB() {
    if (!this.#db) return;
    const jsonString = JSON.stringify(this.#db);
    
    if (this.#saveHook) {
        await this.#saveHook(jsonString);
    } else {
        const tempFile = `${this.#file}.tmp`;
        await writeFile(tempFile, jsonString);
        await rename(tempFile, this.#file);
    }
  }

  async #appendAOF(ops: { op: string; instructions: any }[]) {
      if (ops.length === 0) return;
      const lines = ops.map(o => JSON.stringify(o)).join("\n") + "\n";
      await appendFile(this.#aofFile, lines);
  }

  async compact() {
      return this.#mutex.runExclusive(async () => {
          if (!this.#db) await this.#loadDB();
          await this.#saveDB();
          if (this.#aof && existsSync(this.#aofFile)) {
              await unlink(this.#aofFile);
          }
      });
  }

  async transaction(callback: (tx: Transaction) => any) {
    return this.#mutex.runExclusive(async () => {
        const self = this;

        if (!this.#db) {
        await this.#loadDB();
        }
        
        this.#pendingOperations = []; // Reset pending ops

        const wrap = (method: string, fn: Function) => {
            return (instructions: any) => {
                if (this.#aof) {
                    this.#pendingOperations.push({ op: method, instructions });
                }
                return fn(instructions);
            };
        };

        const tx: Transaction = {
        create: wrap("create", this.create.bind(self)),
        update: wrap("update", this.update.bind(self)),
        destroy: wrap("destroy", this.destroy.bind(self)),
        find: this.find.bind(self),
        findMany: this.findMany.bind(self),
        createMany: wrap("createMany", this.createMany.bind(self)),
        dropCollection: wrap("dropCollection", this.dropCollection.bind(self)),
        dropIndex: wrap("dropIndex", this.dropIndex.bind(self)),
        rewriteCollection: wrap("rewriteCollection", this.rewriteCollection.bind(self)),
        ensureIndex: wrap("ensureIndex", this.ensureIndex.bind(self)),
        };
        try {
        const payload = await callback(tx);

        if (this.#aof) {
            await this.#appendAOF(this.#pendingOperations);
        } else {
            await this.#saveDB();
        }
        
        this.#pendingOperations = []; // Clear after write

        return payload;
        } catch (error) {
        console.log(error);
        await this.#loadDB(); // Reload to revert state
        throw error; // Re-throw so caller knows it failed
        }
    });
  }

  #populate(item: any, rules: Populate[]) {
    if (!item) return item;
    const populatedItem = { ...item };
    
    for (const rule of rules) {
        const { field, collection, targetField = "_id" } = rule;
        const value = populatedItem[field];
        
        if (value && this.#db && this.#db[collection]) {
             // Find the related document
             // We can use find logic here, but since it's by ID (usually), we can optimize or just scan default index
             // Assuming default index for now or scanning all if not found in default
             // A simple scan of default index is safest if we don't know where it is
             // But wait, if we have an ID, we don't know which index it is in unless we scan all or use a lookup
             // SencilloDB structure: collection -> index -> array of items
             
             let relatedDoc = null;
             const coll = this.#db[collection];
             const keys = Object.keys(coll);
             
             for (const key of keys) {
                 if (key === "__stats" || key === "__secondary_indexes") continue; // Skip internal keys
                 if (Array.isArray(coll[key])) {
                     const found = (coll[key] as any[]).find(i => i[targetField] === value);
                     if (found) {
                         relatedDoc = found;
                         break;
                     }
                 }
             }

             if (relatedDoc) {
                 populatedItem[field] = relatedDoc;
             }
        }
    }
    return populatedItem;
  }

  create(instructions: Instructions) {
    let {
      collection = "default",
      index = "default",
      data = false,
    } = instructions;
    if (!data) {
      throw new ValidationError("CREATE ERROR: no data given");
    }

    if (!this.#db) throw new DatabaseNotLoadedError();

    if (!this.#db[collection]) {
      this.#db[collection] = { __stats: { inserted: 0, total: 0 }, __id_map: {} };
    }

    if (index instanceof Function) {
      index = index(data);
    }

    // Ensure index is a string at this point
    const indexKey = index as string;

    if (!this.#db[collection][indexKey]) {
      this.#db[collection][indexKey] = [];
    }

    if (typeof data != "object") {
      throw new ValidationError("CREATE ERROR: data is not an object");
    }

    const _id = ++this.#db[collection].__stats.inserted;

    this.#db[collection].__stats.total += 1;

    const newItem = { ...data, _id };

    (this.#db[collection][indexKey] as any[]).push(newItem);
    
    // Update ID Map
    if (!this.#db[collection].__id_map) this.#db[collection].__id_map = {};
    this.#db[collection].__id_map![_id] = indexKey;

    // Update Secondary Indexes
    if (this.#db[collection].__secondary_indexes) {
        for (const field in this.#db[collection].__secondary_indexes) {
            if (newItem[field] !== undefined) {
                const value = String(newItem[field]);
                if (!this.#db[collection].__secondary_indexes![field][value]) {
                    this.#db[collection].__secondary_indexes![field][value] = [];
                }
                this.#db[collection].__secondary_indexes![field][value].push(_id);
            }
        }
    }

    return newItem;
  }

  update(instructions: Instructions) {
    let {
      _id = undefined,
      collection = "default",
      index = "default",
      data = false,
    } = instructions;

    let new_index: string | ((data: any) => string) | undefined = undefined;
    if (!_id) {
      throw new ValidationError("UPDATE ERROR: no _id to update");
    }

    if (!data) {
      throw new ValidationError("UPDATE ERROR: no data given");
    }

    if (!this.#db) throw new DatabaseNotLoadedError();

    if (!this.#db[collection]) {
      throw new CollectionNotFoundError(collection);
    }

    if (typeof data != "object") {
      throw new ValidationError("UPDATE ERROR: data is not an object");
    }

    if (typeof index === "object" && "current" in index && "new" in index) {
        new_index = index.new;
        index = index.current;
    }

    const indexKey = index as string;

    if (!this.#db[collection][indexKey]) {
      throw new IndexNotFoundError(indexKey);
    }

    const list = this.#db[collection][indexKey] as any[];
    const itemIndex = list.findIndex(
      (item) => item._id === _id
    );

    if (itemIndex == -1) {
      throw new DocumentNotFoundError(_id);
    }

    const oldItem = list[itemIndex];

    const newItem = {
      ...data,
      _id,
    };

    if (new_index) {
      list.splice(itemIndex, 1);
      let targetIndex = new_index;

      if (typeof targetIndex === "function") {
        targetIndex = targetIndex(newItem);
      }
      
      const targetIndexKey = targetIndex as string;

      if (!this.#db[collection][targetIndexKey]) {
        this.#db[collection][targetIndexKey] = [];
      }
      
      (this.#db[collection][targetIndexKey] as any[]).push(newItem);
      
      // Update ID Map
      if (!this.#db[collection].__id_map) this.#db[collection].__id_map = {};
      this.#db[collection].__id_map![_id] = targetIndexKey;
    } else {
        list[itemIndex] = newItem;
    }

    // Update Secondary Indexes
    if (this.#db[collection].__secondary_indexes) {
        for (const field in this.#db[collection].__secondary_indexes) {
            // Remove old value
            if (oldItem[field] !== undefined) {
                const oldValue = String(oldItem[field]);
                const bucket = this.#db[collection].__secondary_indexes![field][oldValue];
                if (bucket) {
                    const idIndex = bucket.indexOf(_id);
                    if (idIndex > -1) bucket.splice(idIndex, 1);
                    if (bucket.length === 0) delete this.#db[collection].__secondary_indexes![field][oldValue];
                }
            }
            // Add new value
            if (newItem[field] !== undefined) {
                const newValue = String(newItem[field]);
                if (!this.#db[collection].__secondary_indexes![field][newValue]) {
                    this.#db[collection].__secondary_indexes![field][newValue] = [];
                }
                this.#db[collection].__secondary_indexes![field][newValue].push(_id);
            }
        }
    }

    return newItem;
  }

  destroy(instructions: Instructions) {
    const {
      _id = undefined,
      collection = "default",
      index = "default",
    } = instructions;

    if (!_id) {
      throw new ValidationError("DESTROY ERROR: no _id to update");
    }

    if (!this.#db) throw new DatabaseNotLoadedError();

    if (!this.#db[collection]) {
      throw new CollectionNotFoundError(collection);
    }

    const indexKey = index as string;

    if (!this.#db[collection][indexKey]) {
      throw new IndexNotFoundError(indexKey);
    }

    const list = this.#db[collection][indexKey] as any[];
    const itemIndex = list.findIndex(
      (item) => item._id === _id
    );

    if (itemIndex === -1) return undefined;

    const destroyedItem = list.splice(itemIndex, 1)[0];
    this.#db[collection].__stats.total -= 1;

    // Update ID Map
    if (this.#db[collection].__id_map) {
        delete this.#db[collection].__id_map![_id];
    }

    // Update Secondary Indexes
    if (this.#db[collection].__secondary_indexes) {
        for (const field in this.#db[collection].__secondary_indexes) {
            if (destroyedItem[field] !== undefined) {
                const value = String(destroyedItem[field]);
                const bucket = this.#db[collection].__secondary_indexes![field][value];
                if (bucket) {
                    const idIndex = bucket.indexOf(_id);
                    if (idIndex > -1) bucket.splice(idIndex, 1);
                    if (bucket.length === 0) delete this.#db[collection].__secondary_indexes![field][value];
                }
            }
        }
    }

    return destroyedItem;
  }

  find(instructions: Instructions) {
    const {
      callback = undefined,
      filter = undefined,
      collection = "default",
      index = undefined,
    } = instructions;

    let matcher = callback;

    if (!matcher) {
        if (filter) {
            matcher = (item: any) => match(item, filter);
        } else {
            throw new ValidationError("FIND ERROR: no callback or filter property");
        }
    }

    if (!this.#db) throw new DatabaseNotLoadedError();

    if (!this.#db[collection]) {
      throw new CollectionNotFoundError(collection);
    }

    // Optimization: Check Secondary Indexes
    if (filter && this.#db[collection].__secondary_indexes && this.#db[collection].__id_map) {
        for (const field in filter) {
            // Check for direct equality or $eq
            let value = undefined;
            if (typeof filter[field] !== 'object') {
                value = filter[field];
            } else if (filter[field].$eq !== undefined) {
                value = filter[field].$eq;
            }

            if (value !== undefined && this.#db[collection].__secondary_indexes![field]) {
                const stringValue = String(value);
                const ids = this.#db[collection].__secondary_indexes![field][stringValue];
                
                if (ids && ids.length > 0) {
                    // Use ID Map to find items quickly
                    for (const id of ids) {
                        const idx = this.#db[collection].__id_map![id];
                        if (idx && this.#db[collection][idx]) {
                            const item = (this.#db[collection][idx] as any[]).find(i => i._id === id);
                            if (item && matcher(item)) { // Check against full matcher
                                if (instructions.populate) {
                                    return this.#populate(item, instructions.populate);
                                }
                                return item;
                            }
                        }
                    }
                    return undefined; // Found in index but not matching filter (shouldn't happen for equality, but maybe matcher has other checks)
                } else {
                    return undefined; // Index exists but empty for this value, so no match
                }
            }
        }
    }

    if (index) {
      const indexKey = index as string;
      if (!this.#db[collection][indexKey]) {
        throw new IndexNotFoundError(indexKey);
      }

      const result = (this.#db[collection][indexKey] as any[]).find(matcher);
      if (instructions.populate && result) {
          return this.#populate(result, instructions.populate);
      }
      return result;
    }

    const keys = Object.keys(this.#db[collection]);
    const coll = this.#db[collection];

    let found = false;
    let item;

    for (let key of keys) {
      if (!found && Array.isArray(coll[key])) {
        const findResult = (coll[key] as any[]).find(matcher);
        if (findResult) {
          item = findResult;
          found = true;
        }
      }
    }

    if (instructions.populate && item) {
        return this.#populate(item, instructions.populate);
    }

    return item;
  }

  findMany(instructions: Instructions) {
    const {
      callback = undefined,
      filter = undefined,
      collection = "default",
      index = undefined,
      sort = (x: any, y: any) => x._id - y._id,
    } = instructions;

    let matcher = callback;

    if (!matcher) {
        if (filter) {
            matcher = (item: any) => match(item, filter);
        } else {
            throw new ValidationError("FINDMANY ERROR: no callback or filter property");
        }
    }

    if (!this.#db) throw new DatabaseNotLoadedError();

    if (!this.#db[collection]) {
      throw new CollectionNotFoundError(collection);
    }

    // Optimization: Check Secondary Indexes
    if (filter && this.#db[collection].__secondary_indexes && this.#db[collection].__id_map) {
        for (const field in filter) {
            // Check for direct equality or $eq
            let value = undefined;
            if (typeof filter[field] !== 'object') {
                value = filter[field];
            } else if (filter[field].$eq !== undefined) {
                value = filter[field].$eq;
            }

            if (value !== undefined && this.#db[collection].__secondary_indexes![field]) {
                const stringValue = String(value);
                const ids = this.#db[collection].__secondary_indexes![field][stringValue];
                
                if (ids && ids.length > 0) {
                    const results: any[] = [];
                    // Use ID Map to find items quickly
                    for (const id of ids) {
                        const idx = this.#db[collection].__id_map![id];
                        if (idx && this.#db[collection][idx]) {
                            const item = (this.#db[collection][idx] as any[]).find(i => i._id === id);
                            if (item && matcher(item)) { // Check against full matcher
                                results.push(item);
                            }
                        }
                    }
                    if (sort) {
                        results.sort(sort);
                    }
                    if (instructions.populate) {
                        return results.map(item => this.#populate(item, instructions.populate!));
                    }
                    return results;
                } else {
                    return []; // Index exists but empty for this value, so no matches
                }
            }
        }
    }

    if (index) {
      const indexKey = index as string;
      if (!this.#db[collection][indexKey]) {
        throw new IndexNotFoundError(indexKey);
      }

      let results = (this.#db[collection][indexKey] as any[]).filter(matcher);
      
      if (sort) {
          results.sort(sort);
      }

      if (instructions.populate) {
          results = results.map(item => this.#populate(item, instructions.populate!));
      }
      
      return results;
    }

    const keys = Object.keys(this.#db[collection]);
    const coll = this.#db[collection];

    let items: any[] = [];

    for (let key of keys) {
      if (key === "__stats" || key === "__secondary_indexes" || key === "__id_map") continue; // Skip internal keys
      if (Array.isArray(coll[key])) {
        const findResult = (coll[key] as any[]).filter(matcher);
        if (findResult.length > 0) {
          items = [...items, ...findResult];
        }
      }
    }

    if (sort) {
      items.sort(sort);
    }

    if (instructions.populate) {
        items = items.map(item => this.#populate(item, instructions.populate!));
    }

    return items;
  }

  createMany(instructions: Instructions) {
    const { data, index = "default", collection = "default" } = instructions;

    if (!Array.isArray(data)) {
      throw new ValidationError("CREATEMANY ERROR: data must be an array of objects");
    }

    if (!data.every((item: any) => typeof item === "object")) {
      throw new ValidationError("CREATEMANY ERROR: all items in array must be objects");
    }

    const items = [];

    for (let item of data) {
      if (typeof index === "function") {
        const newItem = this.create({
          data: item,
          index: index(item),
          collection,
        });
        items.push(newItem);
      } else {
        const newItem = this.create({
          data: item,
          index: index as string,
          collection,
        });
        items.push(newItem);
      }
    }

    return items;
  }

  dropCollection(instructions: Instructions) {
    const { collection } = instructions;
    if (!collection || !this.#db) return;

    delete this.#db[collection];
  }

  dropIndex(instructions: Instructions) {
    const { collection, index } = instructions;
    if (!collection || !index || !this.#db) return;

    const indexKey = index as string;

    if (this.#db[collection] && this.#db[collection][indexKey]) {
      // Remove items from ID map that were in this index
      if (this.#db[collection].__id_map) {
          const itemsInIndex = this.#db[collection][indexKey] as any[];
          if (Array.isArray(itemsInIndex)) {
              for (const item of itemsInIndex) {
                  delete this.#db[collection].__id_map![item._id];
              }
          }
      }
      delete this.#db[collection][indexKey];
    }
  }

  ensureIndex(instructions: { collection: string; field: string }) {
    const { collection, field } = instructions;
    if (!this.#db) throw new DatabaseNotLoadedError();
    if (!this.#db[collection]) {
        this.#db[collection] = { __stats: { inserted: 0, total: 0 }, __id_map: {} };
    }

    if (!this.#db[collection].__secondary_indexes) {
        this.#db[collection].__secondary_indexes = {};
    }

    if (!this.#db[collection].__secondary_indexes![field]) {
        this.#db[collection].__secondary_indexes![field] = {};
    }

    // Populate Index
    const coll = this.#db[collection];
    const keys = Object.keys(coll);
    
    for (const key of keys) {
        if (key === "__stats" || key === "__secondary_indexes" || key === "__id_map") continue;
        if (Array.isArray(coll[key])) {
            for (const item of (coll[key] as any[])) {
                if (item[field] !== undefined) {
                    const value = String(item[field]);
                    if (!this.#db[collection].__secondary_indexes![field][value]) {
                        this.#db[collection].__secondary_indexes![field][value] = [];
                    }
                    this.#db[collection].__secondary_indexes![field][value].push(item._id);
                }
            }
        }
    }
  }

  rewriteCollection(instructions: Instructions) {
    const {
      collection = undefined,
      index = "default",
      sort = (x: any, y: any) => x._id - y._id,
    } = instructions;

    if (!collection) {
      throw new ValidationError("rewriteCollection Error: No Collection Specified");
    }

    if (!this.#db) throw new DatabaseNotLoadedError();

    if (!this.#db[collection]) {
      throw new CollectionNotFoundError(collection);
    }

    const keys = Object.keys(this.#db[collection]);
    const items: any[] = [];
    
    // Clear ID Map if exists
    if (this.#db[collection].__id_map) this.#db[collection].__id_map = {};

    for (let key of keys) {
      if (key === "__stats" || key === "__secondary_indexes" || key === "__id_map") continue;
      if (Array.isArray(this.#db[collection][key])) {
        items.push(...(this.#db[collection][key] as any[]));
      }
    }

    //sort the data
    items.sort(sort);

    // drop collection
    delete this.#db[collection];

    // rewrite all data
    this.createMany({
      data: items,
      index,
      collection,
    });
  }
}

export const quickTx = (db: SencilloDB) => {
  return async (operation: keyof Transaction, instructions: Instructions) => {
    return db.transaction((tx) => {
      // @ts-ignore
      return tx[operation](instructions);
    });
  };
};

export const createResourceManager = (config: {
    schema?: [string, any][],
    db?: SencilloDB,
    index?: (obj: any) => string,
    collection?: string
}) => {
  let {
    schema = [],
    db = undefined,
    index = () => "default",
    collection = "default",
  } = config;

  if (!db) throw new DatabaseNotLoadedError();

  const qtx = quickTx(db);

  return {
    validate: (obj: any) => {
      const keys = Object.keys(obj);

      for (let property of schema) {
        if (!keys.includes(property[0])) {
          throw new ValidationError(`RESOURE VALIDATION ERROR: ${property[0]} missing in some of the data presented`);
        }

        // console.log(obj[property[0]].constructor === property[1]);
        if (obj[property[0]].constructor !== property[1]) {
          throw new ValidationError(`RESOURE VALIDATION ERROR: ${property[0]} is not of type ${property[1]}`);
        }
      }

      return true;
    },
    execute(operation: keyof Transaction, instructions: Instructions) {
      if (["create", "createMany", "update"].includes(operation)) {
        if (Array.isArray(instructions.data)) {
          for (let i of instructions.data) {
            this.validate(i);
          }
        } else {
          if (typeof instructions.data !== "object") {
            throw new ValidationError("EXECUTE ERROR: data is not object or array");
          }
          this.validate(instructions.data);
        }
      }

      let indexToUse: string | ((data: any) => string) | undefined = index;

      if (["delete", "update", "find", "findMany", "dropIndex"].includes(operation)) {
        if (!instructions.index) {
          indexToUse = undefined;
        }
      }

      return qtx(operation, { index: indexToUse, collection, ...instructions });
    },
  };
};
